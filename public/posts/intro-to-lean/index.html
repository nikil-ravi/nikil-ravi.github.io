<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introduction to Lean | Nikil Ravi</title><meta name=keywords content="lean,theorem-prover,functional-programming,formal-verification"><meta name=description content="An introduction to Lean, a functional programming language and interactive theorem prover"><meta name=author content="Nikil Ravi"><link rel=canonical href=http://localhost:1313/posts/intro-to-lean/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/intro-to-lean/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/intro-to-lean/"><meta property="og:site_name" content="Nikil Ravi"><meta property="og:title" content="Introduction to Lean"><meta property="og:description" content="An introduction to Lean, a functional programming language and interactive theorem prover"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-01T00:00:00-05:00"><meta property="article:modified_time" content="2024-01-01T00:00:00-05:00"><meta property="article:tag" content="Lean"><meta property="article:tag" content="Theorem-Prover"><meta property="article:tag" content="Functional-Programming"><meta property="article:tag" content="Formal-Verification"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction to Lean"><meta name=twitter:description content="An introduction to Lean, a functional programming language and interactive theorem prover"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Introduction to Lean","item":"http://localhost:1313/posts/intro-to-lean/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introduction to Lean","name":"Introduction to Lean","description":"An introduction to Lean, a functional programming language and interactive theorem prover","keywords":["lean","theorem-prover","functional-programming","formal-verification"],"articleBody":"Introduction to Lean Lean is a functional programming language that doubles as an interactive theorem prover. It combines the elegance of functional programming with powerful formal verification capabilities, making it ideal for both software development and mathematical proofs.\nWhat is Lean? Lean was created by Leonardo de Moura at Microsoft Research and is now developed as an open-source project. Unlike traditional proof assistants like Coq or Isabelle, Lean emphasizes:\nPerformance: Fast compilation and execution Usability: Clean, readable syntax Interactivity: Real-time feedback and proof development Extensibility: Metaprogramming capabilities Basic Mathematical Expressions Lean supports mathematical notation seamlessly. Here are some examples:\nInline math: $\\alpha + \\beta$\nDisplay math: $$\\alpha + \\beta$$\nDefining Types In Lean, we use the inductive keyword to define new types. Here’s how we define the natural numbers:\n1 2 3 inductive Nat : Type | zero : Nat | succ : Nat → Nat This creates a type Nat with two constructors: zero and succ (successor).\nFunctions and Recursion We can define functions using pattern matching and recursion:\n1 2 3 4 def add (n m : Nat) : Nat := match n with | zero =\u003e m | succ n' =\u003e succ (add n' m) This defines addition recursively: add n m adds n and m by repeatedly applying the successor function.\nTheorem Proving One of Lean’s most powerful features is its theorem proving capabilities. Here’s a simple proof by induction:\n1 2 3 4 5 6 theorem add_zero (n : Nat) : add n zero = n := by induction n case zero =\u003e rfl -- reflexive equality, since add zero zero = zero case succ n' ih =\u003e rw [add, ih] -- rewrite using the inductive hypothesis This theorem states that adding zero to any natural number n gives back n. The proof uses mathematical induction:\nBase case: When n = zero, we have add zero zero = zero by definition Inductive step: Assuming add n' zero = n' for some n', we show add (succ n') zero = succ n' Why Lean Matters Lean is particularly valuable because:\nFormal Verification: Prove code correctness mathematically Education: Learn programming and logic simultaneously Research: Build new mathematical theories and verify them Industry: Ensure critical software systems are bug-free Getting Started To install Lean, you can use the official installer or package managers:\n1 2 3 4 5 6 # Using curl curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf | sh # Or using package managers # macOS with Homebrew: brew install lean # Ubuntu/Debian: sudo apt install lean Then create your first Lean file:\n1 2 3 def hello := \"Hello, Lean!\" #eval hello -- This will print \"Hello, Lean!\" Next Steps This post only scratches the surface of what Lean can do. In future posts, we’ll explore:\nDependent types and their applications Advanced theorem proving techniques Building verified data structures Integration with other programming languages Lean represents the future of software development where correctness is guaranteed through mathematical proof rather than just testing.\n","wordCount":"493","inLanguage":"en","datePublished":"2024-01-01T00:00:00-05:00","dateModified":"2024-01-01T00:00:00-05:00","author":{"@type":"Person","name":"Nikil Ravi"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/intro-to-lean/"},"publisher":{"@type":"Organization","name":"Nikil Ravi","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Nikil Ravi (Alt + H)">Nikil Ravi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/work/ title=Work><span>Work</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Introduction to Lean
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentColor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-description>An introduction to Lean, a functional programming language and interactive theorem prover</div><div class=post-meta><span title='2024-01-01 00:00:00 -0500 -0500'>January 1, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;493 words&nbsp;·&nbsp;Nikil Ravi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#what-is-lean>What is Lean?</a></li><li><a href=#basic-mathematical-expressions>Basic Mathematical Expressions</a></li><li><a href=#defining-types>Defining Types</a></li><li><a href=#functions-and-recursion>Functions and Recursion</a></li><li><a href=#theorem-proving>Theorem Proving</a></li><li><a href=#why-lean-matters>Why Lean Matters</a></li><li><a href=#getting-started>Getting Started</a></li><li><a href=#next-steps>Next Steps</a></li></ul></nav></div></details></div><div class=post-content><h1 id=introduction-to-lean>Introduction to Lean<a hidden class=anchor aria-hidden=true href=#introduction-to-lean>#</a></h1><p>Lean is a functional programming language that doubles as an interactive theorem prover. It combines the elegance of functional programming with powerful formal verification capabilities, making it ideal for both software development and mathematical proofs.</p><h2 id=what-is-lean>What is Lean?<a hidden class=anchor aria-hidden=true href=#what-is-lean>#</a></h2><p>Lean was created by Leonardo de Moura at Microsoft Research and is now developed as an open-source project. Unlike traditional proof assistants like Coq or Isabelle, Lean emphasizes:</p><ul><li><strong>Performance</strong>: Fast compilation and execution</li><li><strong>Usability</strong>: Clean, readable syntax</li><li><strong>Interactivity</strong>: Real-time feedback and proof development</li><li><strong>Extensibility</strong>: Metaprogramming capabilities</li></ul><h2 id=basic-mathematical-expressions>Basic Mathematical Expressions<a hidden class=anchor aria-hidden=true href=#basic-mathematical-expressions>#</a></h2><p>Lean supports mathematical notation seamlessly. Here are some examples:</p><p><strong>Inline math:</strong> $\alpha + \beta$</p><p><strong>Display math:</strong>
$$\alpha + \beta$$</p><h2 id=defining-types>Defining Types<a hidden class=anchor aria-hidden=true href=#defining-types>#</a></h2><p>In Lean, we use the <code>inductive</code> keyword to define new types. Here&rsquo;s how we define the natural numbers:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=kn>inductive</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>zero</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>succ</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Nat</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This creates a type <code>Nat</code> with two constructors: <code>zero</code> and <code>succ</code> (successor).</p><h2 id=functions-and-recursion>Functions and Recursion<a hidden class=anchor aria-hidden=true href=#functions-and-recursion>#</a></h2><p>We can define functions using pattern matching and recursion:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=kn>def</span><span class=w> </span><span class=n>add</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>match</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>with</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>zero</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>succ</span><span class=w> </span><span class=n>n&#39;</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>succ</span><span class=w> </span><span class=o>(</span><span class=n>add</span><span class=w> </span><span class=n>n&#39;</span><span class=w> </span><span class=n>m</span><span class=o>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This defines addition recursively: <code>add n m</code> adds <code>n</code> and <code>m</code> by repeatedly applying the successor function.</p><h2 id=theorem-proving>Theorem Proving<a hidden class=anchor aria-hidden=true href=#theorem-proving>#</a></h2><p>One of Lean&rsquo;s most powerful features is its theorem proving capabilities. Here&rsquo;s a simple proof by induction:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=kn>theorem</span><span class=w> </span><span class=n>add_zero</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>add</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=n>zero</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w> </span><span class=k>by</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>induction</span><span class=w> </span><span class=n>n</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>case</span><span class=w> </span><span class=n>zero</span><span class=w> </span><span class=bp>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rfl</span><span class=w>  </span><span class=c1>-- reflexive equality, since add zero zero = zero</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>case</span><span class=w> </span><span class=n>succ</span><span class=w> </span><span class=n>n&#39;</span><span class=w> </span><span class=n>ih</span><span class=w> </span><span class=bp>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rw</span><span class=w> </span><span class=o>[</span><span class=n>add</span><span class=o>,</span><span class=w> </span><span class=n>ih</span><span class=o>]</span><span class=w>  </span><span class=c1>-- rewrite using the inductive hypothesis</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>This theorem states that adding zero to any natural number <code>n</code> gives back <code>n</code>. The proof uses mathematical induction:</p><ol><li><strong>Base case</strong>: When <code>n = zero</code>, we have <code>add zero zero = zero</code> by definition</li><li><strong>Inductive step</strong>: Assuming <code>add n' zero = n'</code> for some <code>n'</code>, we show <code>add (succ n') zero = succ n'</code></li></ol><h2 id=why-lean-matters>Why Lean Matters<a hidden class=anchor aria-hidden=true href=#why-lean-matters>#</a></h2><p>Lean is particularly valuable because:</p><ul><li><strong>Formal Verification</strong>: Prove code correctness mathematically</li><li><strong>Education</strong>: Learn programming and logic simultaneously</li><li><strong>Research</strong>: Build new mathematical theories and verify them</li><li><strong>Industry</strong>: Ensure critical software systems are bug-free</li></ul><h2 id=getting-started>Getting Started<a hidden class=anchor aria-hidden=true href=#getting-started>#</a></h2><p>To install Lean, you can use the official installer or package managers:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Using curl</span>
</span></span><span class=line><span class=cl>curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf <span class=p>|</span> sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Or using package managers</span>
</span></span><span class=line><span class=cl><span class=c1># macOS with Homebrew: brew install lean</span>
</span></span><span class=line><span class=cl><span class=c1># Ubuntu/Debian: sudo apt install lean</span>
</span></span></code></pre></td></tr></table></div></div><p>Then create your first Lean file:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=kn>def</span><span class=w> </span><span class=n>hello</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w> </span><span class=s2>&#34;Hello, Lean!&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=bp>#</span><span class=n>eval</span><span class=w> </span><span class=n>hello</span><span class=w>  </span><span class=c1>-- This will print &#34;Hello, Lean!&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=next-steps>Next Steps<a hidden class=anchor aria-hidden=true href=#next-steps>#</a></h2><p>This post only scratches the surface of what Lean can do. In future posts, we&rsquo;ll explore:</p><ul><li>Dependent types and their applications</li><li>Advanced theorem proving techniques</li><li>Building verified data structures</li><li>Integration with other programming languages</li></ul><p>Lean represents the future of software development where correctness is guaranteed through mathematical proof rather than just testing.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/lean/>Lean</a></li><li><a href=http://localhost:1313/tags/theorem-prover/>Theorem-Prover</a></li><li><a href=http://localhost:1313/tags/functional-programming/>Functional-Programming</a></li><li><a href=http://localhost:1313/tags/formal-verification/>Formal-Verification</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/2024-01-14-information-theory/><span class=title>« Prev</span><br><span>Information Theory</span></a></nav></footer></article></main><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>